## [Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/?envType=problem-list-v2&envId=rab78cw1)

### 문제
- 주어진 막대 길이 배열에서, 두 막대를 선택해서 x축, y축을 곱했을 때 가장 큰 수조의 크기가 될 수 있는 값을 찾는 문제 

### 해결
- **풀이1 : 브루트 포스**
   - 반복문 두 개로 총 시간 복잡도 O(N^2)(n * (n - 1))의 브루트 포스로 처리하려고 함.
   - 첫 번째 막대부터 시작해, 해당 막대와 다른 막대 사이의 높이값을 비교하고, (두 막대 중 작은 높이 값 * 두 막대의 거리) 연산을 통해 수조의 크기를 구하고, 이전에 저장되었던 크기값들과 비교연산을 진행해 가장 큰 수조의 크기 값을 구함.
   - 메모이제이션을 사용해 이미 해당 막대 길이 기준 최대 수조 크기 값이 나왔다면 해당 막대의 연산은 처리하지 않고 스킵.
   - 또 기준이 되는 막대의 길이가 0이면 스킵.
   - 메모이제이션이나 조건문을 통해 최대한 시간 복잡도 개선을 해줬더니 답이 통과되긴했으나, 2281ms의 실행 속도가 나와 Beat 8%밖에 평가를 못 받아서, 투 포인터로 다시 문제 해결.
- **풀이2 : 투 포인터**
   - 왼쪽 인덱스 포인터와 오른쪽 인덱스 포인터를 둔다.
   - 왼쪽 막대 길이와 오른쪽 막대 길이를 비교해, (두 막대 중 작은 높이 값 * 두 막대의 거리) 연산을 통해 수조의 크기를 구하고, 이전에 저장되었던 크기값들과 비교연산을 진행해 가장 큰 수조의 크기 값을 구함.
   - 만약 왼쪽 막대 길이가 짧았다면 해당 막대 길이보다 긴 막대가 나올때까지 왼쪽 인덱스 포인터를 플러스.
   - 만약 오른쪽 막대 길이가 짧았다면 해당 막대 길이보다 긴 막대가 나올때까지 오른쪽 인덱스 포인터를 마이너스.
   - 포인터를 다 이동시키고 나면, 다시 2번째 과정부터 반복함.
   - 오른쪽 포인터가 왼쪽 포인터보다 인덱스 값이 높을때까지만 위 로직들을 반복.

### 복기
- 해당 문제는 어떤 알고리즘으로 풀지 감이 잘 안 잡혔던 것 같음.
- 투 포인터가 사용되는 문제 케이스를 경험으로 많이 체득하는 것이 중요할 것 같음.
